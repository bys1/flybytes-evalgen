module fbeg::EvalGen

import Type;
import List;
import Map;
import IO;

import lang::flybytes::Syntax;
import lang::flybytes::Compiler;

import fbeg::Switch;
import fbeg::Envx;

private str vl = "io.usethesource.vallang.";

private list[Symbol] currentSymbols;
private map[str, Symbol] declaredSymbols;
private map[Symbol, Type] retTypes;

@reflect
@javaClass{fbeg.EvalGen}
private java &F genEvalFunc(type[&F] funcType, str name);

@reflect
@javaClass{fbeg.EvalGen}
private java map[str,loc] getFuncSrc(list[Stat](str, list[Symbol]) func);

@javaClass{fbeg.EvalGen}
private java loc getDir();

/**
 *  Generates a Flybytes interpreter using the given arguments.
 *
 *  @param funcType         The type of the Rascal function that should be returned. This should be of the form &R(&L), where
 *                          &R is the Rascal type that is the output of the interpreter, and &L is an abstract data type that is its input.
 *  @param actions          A Rascal function that returns a list[Stat] containing the actions/code for each constructor name with its associated arguments.
 *
 *  ===== OPTIONAL PARAMETERS =====
 *
 *  @param retTypes         A map that maps all Symbol::adt AST types to a Flybytes/Java Type, representing the return type for each eval method.
 *                          Each AST type can return a different type of value. If unspecified, the generator attempts to find a type that matches &R.
 *  @param javaToRascal     A Rascal function that returns an expression to convert a Java return value to a Rascal type (? extends IValue).
 *                          This conversion is done at the end of the interpreter, before returning the result to the user.
 *                          By default, this is a call to Rascal's IValueFactory that constructs a return value based on &R.
 *                          If retTypes is specified and adds a custom return type for the root AST type, this function should be specified as well.
 *  @param helperClasses    A list of helper classes that should be compiled and loaded along with the interpreter. Empty by default.
 *  @param fields           A list of fields that the interpreter class should have, which can be used during evaluation.
 *                          By default, this list only includes an "env" field to store an environment.
 *  @param helperMethods    A list of helper methods that should be compiled into the interpreter class and can be used by actions. Empty by default.
 *  @param constructorCode  A list of statements that should be executed before the end of the class constructor. Empty by default, but if unaltered,
                            a statement is added that initializes the "env" field, provided that this field is present.
 *  @param preApplyCode     A list of statements that should be executed prior to evaluation by the "apply" method. Empty by default, but when the
 *                          function type contains exactly one Env (= value) parameter and this list is unaltered, a statement is added that puts
 *                          the Env argument into the "env" field of the class, provided that this field is present.
 *  @param debug            Setting this to true will include line numbers of the actions in the compiled class. The provided actions function
 *                          should be an overloaded function, and the generator will attempt to find the starting line number for each node type.
 */
&F genEval(type[&F] funcType, list[Stat](str, list[Symbol]) actions, map[Symbol, Type] retTypes = (), Exp(Exp, Symbol) javaToRascal = callVF,
        list[Class] helperClasses = [], list[Field] fields = defaultFields, list[Method] helperMethods = [], list[Stat] constructorCode = [],
        list[Stat] preApplyCode = [], bool debug = false) {
    ft = addKwTypes(funcType);
    Symbol symbol = ft.symbol.parameters[0];
    str evalName = "<symbol.name>Eval";
    Symbol ret = ft.symbol.ret;
    map[Symbol, Production] definitions = ft.definitions;
    map[Symbol, Type] types = (sym : symbolToType(extractRet(ret)) | sym <- definitions) + retTypes;
    compileHelpers(helperClasses);
    compileEval(symbol, evalName, ret, definitions, types, actions, javaToRascal, fields, helperMethods, addInitEnv(constructorCode, fields),
            addPutEnv(ft, preApplyCode, fields), debug);
    return typeCast(funcType, genEvalFunc(ft, evalName));
}

private type[value] addKwTypes(type[&T] t) {
    Symbol s = t.symbol;
    s.kwTypes = [label("env", \value()), label("globalEnv", \value())];
    return type(s, t.definitions);
}

/**
 *  Returns an interpreter function of the given type for an already generated Flybytes interpreter.
 *  Before calling this function, an interpreter should be generated by calling the genEval function with actions.
 *  If an interpreter is not present, the behaviour of this function is undefined.
 *  The function type should match the function type used when generating the interpreter. This function simply
 *  loads the generated class and creates a Rascal function to call the interpreter.
 *
 *  @param funcType The type of the Rascal function that should be returned. This should be of the form &R(&L), where
 *                  &R is the Rascal type that is the output of the interpreter, and &L is an abstract data type that
 *                  is its input. This type should match the function type used when generating the interpreter.
 */
&F genEval(type[&F] funcType) {
    Symbol symbol = funcType.symbol.parameters[0];
    str evalName = "<symbol.name>Eval";
    return genEvalFunc(funcType, evalName);
}

/**
 *  Generates a partial interpreter of the given type, for an already generated Flybytes interpreter of the given main type.
 *  Before calling this function, an interpreter should be generated by calling the genEval function with the given main
 *  type and corresponding actions. If an interpreter is not present, the behaviour of this function is undefined.
 *  A function type, and optionally a return type evalRet and a javaToRascal function, should be given such that the types
 *  match the types in the generated interpreter. Otherwise, the behaviour of this function is undefined.
 *
 *  @param funcType     The type of the Rascal function that should be returned. This should be of the form &R(&T), where
 *                      &R is the Rascal type that is the output of the partial interpreter, and &T is an abstract data
 *                      type that is its input.
 *  @param mainType     The (main) type of the previously generated interpreter. If an interpreter was previously generated
 *                      by calling genEval with the function type &X(&L), the type &L should be passed here.
 *  @param evalRet      The Flybytes/Java type that is returned by the eval method in the interpreter for the AST type for which
 *                      a partial interpreter is generated here. By default, this type is inferred from the given function type.
 *  @param javaToRascal A Rascal function that returns an expression to convert a Java return value to a Rascal type (? extends IValue).
 *                      This conversion is done at the end of the interpreter, before returning the result to the user.
 *                      By default, this is a call to Rascal's IValueFactory that constructs a return value based on &R.
 *                      If evalRet is specified, this function should be specified as well.
 *  @param preApplyCode A list of statements that should be executed prior to evaluation by the "apply" method. Empty by default.
 */
&F genEvalPartial(type[&F] funcType, type[&L <: node] mainType, Type evalRet = \void(), Exp(Exp, Symbol) javaToRascal = callVF, list[Stat] preApplyCode = []) {
    Symbol mainSymbol = mainType.symbol;
    Symbol symbol = funcType.symbol.parameters[0];
    if (mainSymbol == symbol) return genEval(funcType);
    str mainName = "<mainSymbol.name>Eval";
    str evalName = "<mainName><symbol.name>";
    Symbol ret = funcType.symbol.ret;
    Type retType = evalRet == \void() ? symbolToType(extractRet(ret)) : evalRet;
    compileEvalPartial(symbol, evalName, mainName, ret, retType, javaToRascal, preApplyCode);
    return genEvalFunc(funcType, evalName);
}

/**
 *  Gets the subtree, represented by the given symbol, from the current node.
 *  
 *  @param sym Symbol::label defining the subtree to obtain.
 */
Exp getArg(sym: Symbol::label(_, _)) {
    return invokeInterface(
        object("<vl>IConstructor"),
        load("arg"),
        methodDesc(
            object("<vl>IValue"),
            "get",
            [integer()]
        ),
        [iconst(indexOf(currentSymbols, sym))]
    );
}

/**
 *  Returns a statement that declares a variable with the given name and assigns the subtree,
 *  represented by the given symbol, from the current node, to it (as obtained by getArg).
 *  This variable can later be used to recursively evaluate the subtree by calling recEval(str)
 *  with the variable name.
 *
 *  @param argName  The name of the variable to declare.
 *  @param sym      Symbol::label defining the subtree to obtain.
 */
Stat recDecl(str argName, sym: Symbol::label(str name, Symbol symbol)) {
    declaredSymbols += (name : symbol);
    return decl(object("<vl>IConstructor"), argName, init = getArg(sym));
}

/**
 *  Recursively evaluates the subtree stored in a variable with the given name.
 *  This variable needs to be declared first with a recDecl call.
 *
 *  @param argName The name of the variable holding the subtree to evaluate.
 */
Exp recEval(str varName, Exp env = load("env")) {
    return recEval(label(varName, declaredSymbols[varName]), env = env);
}

/**
 *  Recursively evaluates the subtree, represented by the given symbol, from the current node.
 *
 *  @param sym Symbol::label defining the subtree to obtain.
 */
Exp recEval(sym: Symbol::label(_, Symbol symbol), Exp env = load("env")) {
    return recEval(getArg(sym), symbol, env = env);
}

Exp recEval(Exp exp, type[&T <: node] \type, Exp env = load("env")) = recEval(exp, \type.symbol, env = env);
Exp recEval(Exp exp, Symbol::label(_, Symbol::\set (Symbol sym)), Exp env = load("env")) = recEval(exp, sym, env = env);
Exp recEval(Exp exp, Symbol::label(_, Symbol::\list(Symbol sym)), Exp env = load("env")) = recEval(exp, sym, env = env);

/**
 *  Recursively evaluates the subtree in the given expression, that is of the specified type.
 *
 *  @param exp  The expression representing the subtree to evaluate.
 *  @param sym  Symbol::adt defining the type of the subtree. This is used to determine
                which eval function should be called.
 */
Exp recEval(Exp exp, sym: Symbol::adt(str name, _), Exp env = load("env")) {
    return invokeSpecial(
        this(),
        methodDesc(
            retTypes[sym],
            "eval_<name>",
            [object("<vl>IConstructor"), envType()]
        ),
        [exp, env]
    );
}

/**
 *  Returns the default list of fields for an interpreter class.
 *  By default, this list only contains an "env" field holding an
 *  instance of the environment.
 */
list[Field] defaultFields = [
    field(
        envType(),
        "globalEnv",
        modifiers = {\private()},
        init = newEnv()
    ),
    field(
        envType(),
        "retEnv",
        modifiers = {\private()}
    )
];

/**
 *  Returns the default statement to initialize the environment field.
 *  This statement initializes the "env" field to a new Env instance.
 */
Stat defaultInitEnv = putField(
    object("fbeg.Env"),
    "env",
    newInstance(
        object("fbeg.Env"),
        constructorDesc([object("<vl>IValueFactory")]),
        [load("vf")]
    )
);

/**
 *  Returns the default statement to assign an argument to the environment field.
 *  This statement loads the local variable "args", casts it to an IValue[] array,
 *  and puts its first element into the "env" field.
 */
Stat defaultPutEnv(int index) = putField(
    object("fbeg.Env"),
    "env",
    checkcast(
        aload(
            checkcast(
                load("args"),
                array(object("<vl>IValue"))
            ),
            iconst(index)
        ),
        object("fbeg.Env")
    )
);

private list[Stat] addInitEnv(list[Stat] constructorCode, list[Field] fields) {
    return constructorCode;
    /*if (constructorCode != []) return constructorCode;
    for (Field field <- fields) {
        if (field.\type == object("fbeg.Env") && field.name == "env")
            return [defaultInitEnv];
    }
    return constructorCode;//*/
}

private list[Stat] addPutEnv(type[&F] funcType, list[Stat] preApplyCode, list[Field] fields) {
    return preApplyCode;
    /*if (preApplyCode != []) return preApplyCode;
    list[Symbol] params = funcType.symbol.parameters;
    int first = indexOf(params, \value());
    if (first == -1 || first != lastIndexOf(params, \value())) return preApplyCode;
    for (Field field <- fields) {
        if (field.\type == object("fbeg.Env") && field.name == "env")
            return [defaultPutEnv(first)];
    }
    return preApplyCode;//*/
}

private void compileHelpers(list[Class] helpers) {
    for (Class cl <- helpers) {
        compileClass(cl, getDir() + "<cl.\type.name>.class");
    }
}

/**
 *  Compiles a Flybytes interpreter class using the given arguments.
 *
 *  @param symbol           The Symbol::adt representing the main AST type for the interpreter.
 *  @param evalName         The name of the class to compile.
 *  @param ret              The Symbol directly representing the Rascal type that the interpreter should return.
 *                          The IValueFactory will be used to construct the return value.
 *  @param definitions      A map that maps all Symbol::adt AST types to a Production::choice containing all of their constructors.
 *  @param types            A map that maps all Symbol::adt AST types to a Flybytes/Java Type, representing the return type for each eval method.
 *  @param actions          A Rascal function that returns a list[Stat] containing the actions/code for each constructor name with its associated arguments.
 *  @param javaToRascal     A Rascal function that returns an expression to convert a Java return value to a Rascal type (? extends IValue).
 *                          This conversion is done at the end of the interpreter, before returning the result to the user.
 *  @param fields           A list of fields that the interpreter class should have, which can be used during evaluation.
 *  @param helperMethods    A list of helper methods that should be compiled into the interpreter class and can be used by actions.
 *  @param constructorCode  A list of statements that should be executed before the end of the class constructor.
 *  @param preApplyCode     A list of statements that should be executed prior to evaluation by the "apply" method.
 *  @param debug            Whether to add line numbers for the actions to the compiled class.
 */
private void compileEval(Symbol symbol, str evalName, Symbol ret, map[Symbol, Production] definitions, map[Symbol, Type] types,
        list[Stat](str, list[Symbol]) actions, Exp(Exp, Symbol) javaToRascal, list[Field] fields, list[Method] helperMethods,
        list[Stat] constructorCode, list[Stat] preApplyCode, bool debug) {
    map[str,loc] src = debug ? getFuncSrc(actions) : ();
    Type evalType = object(evalName);
    Class cl = class(
        evalType,
        modifiers = {\public()},
        interfaces = [object("java.util.function.BiFunction")],
        fields = [
            field(
                object("<vl>IValueFactory"),
                "vf",
                modifiers = {\protected(), final()}
            )
        ] + fields,
        methods = [
            // START OF CONSTRUCTOR: Eval(IValueFactory)
            constructor(
                \public(),
                [var(object("<vl>IValueFactory"), "vf")],
                [
                    invokeSuper([], []),
                    putField(object("<vl>IValueFactory"), "vf", load("vf"))
                ] + constructorCode + [
                    \return()
                ]
            ),
            applyMethod(current(), this(), ret, types[symbol], symbol, javaToRascal, preApplyCode)
        ] + [
            // START OF METHOD: eval_X(IConstructor, Map$Immutable)
            method(
                \protected(),
                types[sym],
                "eval_<sym.name>",
                [
                    var(object("<vl>IConstructor"), "arg"),
                    var(envType(), "env")
                ],
                [
                    \try(
                        [
                            stringSwitch(
                                invokeInterface(
                                    object("<vl>IConstructor"),
                                    load("arg"),
                                    methodDesc(
                                        string(),
                                        "getName",
                                        []
                                    ),
                                    []
                                ),
                                (
                                    alt.def.name : getActions(actions, alt.def, alt.symbols, types, src)
                                    | alt <- prod.alternatives
                                ),
                                def = [
                                    \throw(
                                        newInstance(
                                            object("java.lang.IllegalArgumentException"),
                                            constructorDesc([string()]),
                                            [sconst("Unknown constructor type passed to interpreter!")]
                                        )
                                    )
                                ]
                            )
                        ],
                        [
                            // catch(EvalException e) -> Catch EvalException, add current node, rethrow to parent node
                            \catch(
                                object("fbeg.EvalException"),
                                "e",
                                [
                                    \do(
                                        invokeVirtual(
                                            object("fbeg.EvalException"),
                                            load("e"),
                                            methodDesc(
                                                \void(),
                                                "addNode",
                                                [object("<vl>IConstructor")]
                                            ),
                                            [load("arg")]
                                        )
                                    ),
                                    \throw(
                                        load("e")
                                    )
                                ]
                            ),
                            // catch(Throwable t) -> Catch Throwable, create EvalException with current node, rethrow to parent node
                            \catch(
                                object("java.lang.Throwable"),
                                "t",
                                [
                                    \throw(
                                        newInstance(
                                            object("fbeg.EvalException"),
                                            constructorDesc([object("<vl>IConstructor"), object("java.lang.Throwable")]),
                                            [load("arg"), load("t")]
                                        )
                                    )
                                ]
                            ) // end of catch
                        ]
                    ) // end of try
                ]
            )
            | <sym, prod> <- toRel(definitions)
        ] + helperMethods,
        src = |file:///<src[getOneFrom(src)].file>|(0,0,<0,0>,<0,0>)
    );
    compileClass(cl, getDir() + "<evalName>.class", debugMode = debug);
}

/**
 *  Compiles a partial Flybytes interpreter class using the given arguments.
 *
 *  @param symbol           The Symbol::adt representing the AST type for the partial interpreter.
 *  @param evalName         The name of the class to compile.
 *  @param mainName         The name of the main class that is the interpreter that this class should derive from.
 *  @param ret              The Symbol directly representing the Rascal type that the partial interpreter should return.
 *                          The IValueFactory will be used to construct the return value.
 *  @param retType          The Flybytes/Java Type representing the return type of the eval method called by this partial interpreter.
 *  @param javaToRascal     A Rascal function that returns an expression to convert a Java return value to a Rascal type (? extends IValue).
 *                          This conversion is done at the end of the interpreter, before returning the result to the user.
 *  @param preApplyCode     A list of statements that should be executed prior to evaluation by the "apply" method.
 */
private void compileEvalPartial(Symbol symbol, str evalName, str mainName, Symbol ret, Type retType, Exp(Exp, Symbol) javaToRascal, list[Stat] preApplyCode) {
    Type mainType = object(mainName);
    Class cl = class(
        object(evalName),
        modifiers = {\public()},
        super = mainType,
        methods = [
            constructor(
                \public(),
                [var(object("<vl>IValueFactory"), "vf")],
                [
                    invokeSuper([object("<vl>IValueFactory")], [load("vf")]),
                    \return()
                ]
            ),
            applyMethod(mainType, this(), ret, retType, symbol, javaToRascal, preApplyCode)
        ]
    );
    compileClass(cl, getDir() + "<evalName>.class");
}

private Method applyMethod(Type class, Exp instance, Symbol ret, Type retType, Symbol symbol, Exp(Exp, Symbol) javaToRascal, list[Stat] preApplyCode) {
    return method(
        \public(),
        object(),
        "apply",
        [
            var(object(), "args"),
            var(object(), "map")
        ],
        [
            \try(
                preApplyCode +
                [
                    decl(envType(), "env", init = mapGet(load("map"), "env")),
                    decl(envType(), "globalEnv", init = mapGet(load("map"), "globalEnv")),
                    \if(
                        ne(load("globalEnv"), null()),
                        [putField(envType(), "globalEnv", extractEnv(load("globalEnv")))]
                    ),
                    \return(
                        javaToRascal(
                            invokeSpecial(
                                class,
                                instance,
                                methodDesc(
                                    retType,
                                    "eval_<symbol.name>",
                                    [object("<vl>IConstructor"), envType()]
                                ),
                                [
                                    aload(
                                        checkcast(
                                            load("args"),
                                            array(object("<vl>IValue"))
                                        ),
                                        iconst(0)
                                    ),
                                    cond(
                                        Exp::eq(load("env"), null()),
                                        newEnv(),
                                        extractEnv(load("env"))
                                    )
                                ]
                            ),
                            ret
                        )
                    )
                ],
                [
                    \catch(
                        object("fbeg.EvalException"),
                        "e",
                        [
                            \do(
                                invokeVirtual(
                                    object("fbeg.EvalException"),
                                    load("e"),
                                    methodDesc(
                                        \void(),
                                        "printNodeStackTrace",
                                        []
                                    ),
                                    []
                                )
                            ),
                            \throw(
                                invokeVirtual(
                                    object("fbeg.EvalException"),
                                    load("e"),
                                    methodDesc(
                                        object("java.lang.Throwable"),
                                        "getCause",
                                        []
                                    ),
                                    []
                                )
                            )
                        ]
                    ) // end of catch
                ]
            ) // end of try
        ]
    );
}

private Exp extractEnv(Exp env) = invokeVirtual(
    object("fbeg.Env"),
    checkcast(
        env,
        object("fbeg.Env")
    ),
    methodDesc(
        envType(),
        "getMap",
        []
    ),
    []
);

private Exp mapGet(Exp \map, str key) = invokeInterface(
    object("java.util.Map"),
    \map,
    methodDesc(
        object(),
        "get",
        [object()]
    ),
    [sconst(key)]
);

private Type symbolToType(Symbol sym) {
    switch (sym) {
        case \int():            return integer();
        case \bool():           return boolean();
        case \real():           return double();
        case \rat():            return array(integer());
        case \str():            return string();
        case \num():            return double();
        case \void():           return Type::\void();
        case \set(Symbol s):    return array(symbolToType(s));
        case \list(Symbol s):   return array(symbolToType(s));
        default:                return object();
    }
}

private Symbol extractRet(Symbol sym) {
    if (\tuple(list[Symbol] symbols) := sym)
        return [s.symbol | s <- symbols, s.name == "val" || s.symbol != \value()][0];
    return sym;
}

private Exp convertArray(Exp exp, Symbol s) {
    return sblock(
        [
            decl(array(object("<vl>IValue")), "arr", init = newArray(array(object("<vl>IValue")), alength(exp))),
            \for(
                [decl(integer(), "i", init = iconst(0))],
                lt(load("i"), alength(exp)),
                [store("i", add(load("i"), iconst(1)))],
                [
                    astore(
                        load("arr"),
                        load("i"),
                        callVF(aload(exp, load("i")), s)
                    )
                ]
            )
        ],
        load("arr")
    );
}

private Exp callVF(Exp exp, Symbol ret) {
    switch (ret) {
        case \int():            return vf("IInteger",  "integer",  [integer()],                   [exp]);
        case \bool():           return vf("IBool",     "boolean",  [boolean()],                   [exp]);
        case \real():           return vf("IReal",     "real",     [double ()],                   [exp]);
        case \rat():            return vf("IRational", "rational", [integer(), integer()],        [aload(exp, iconst(0)), aload(exp, iconst(1))]);
        case \str():            return vf("IString",   "string",   [string ()],                   [exp]);
        case \num():            return vf("IReal",     "real",     [double ()],                   [exp]);
        case \void():           return checkcast(\null(), object());
        case \set(Symbol s):    return vf("ISet",      "set",      [array(object("<vl>IValue"))], [convertArray(exp, s)]);
        case \list(Symbol s):   return vf("IList",     "list",     [array(object("<vl>IValue"))], [convertArray(exp, s)]);
        case \tuple(list[Symbol] symbols): return vfTuple(exp, symbols);
        default:                return exp;
    }
}

private Exp vf(str ret, str name, list[Type] argTypes, list[Exp] args) {
    return invokeInterface(
        object("<vl>IValueFactory"),
        getField(object("<vl>IValueFactory"), "vf"),
        methodDesc(object("<vl><ret>"), name, argTypes),
        args
    );
}

private Exp vfTuple(Exp exp, list[Symbol] symbols) {
    list[Exp] args = [s.name == "val" || s.symbol != \value()
        ? callVF(exp, s.symbol)
        : invokeVirtual(
            object("fbeg.Env"),
            newInstance(
                object("fbeg.Env"),
                constructorDesc([object("<vl>IValueFactory")]),
                [getField(object("<vl>IValueFactory"), "vf")]
            ),
            methodDesc(
                object("fbeg.Env"),
                "setMap",
                [envType()]
            ),
            [getField(envType(), s.name)]
        )
    | s <- symbols];
    return vf("ITuple", "tuple", [array(object("<vl>IValue"))], [newInitArray(array(object("<vl>IValue")), args)]);
}

private list[Stat] getActions(list[Stat](str, list[Symbol]) func, Symbol::label(str name, _), list[Symbol] symbols, map[Symbol, Type] types, map[str,loc] src) {
    currentSymbols = symbols;
    declaredSymbols = typeCast(#map[str, Symbol], ());
    retTypes = types;
    return [action[src=src[name]] | action <- func(name, symbols)];
}